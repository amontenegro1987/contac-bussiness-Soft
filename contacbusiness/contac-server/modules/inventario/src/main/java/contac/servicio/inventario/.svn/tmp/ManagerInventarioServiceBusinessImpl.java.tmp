/**
 * Copyright 2011 Contac Business Software. All rights reserved.
 * CONTAC PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */

package contac.servicio.inventario;

import contac.modelo.PersistenceManagementServiceFactory;
import contac.modelo.PersistenceManagementServiceFactoryException;
import contac.modelo.eao.almacenEAO.AlmacenEAO;
import contac.modelo.eao.almacenEAO.AlmacenEAOPersistence;
import contac.modelo.eao.articuloEntradaEAO.ArticuloEntradaEAO;
import contac.modelo.eao.articuloEntradaEAO.ArticuloEntradaEAOPersistence;
import contac.modelo.eao.articuloLevantamientoFisicoEAO.ArticuloLevantamientoFisicoEAO;
import contac.modelo.eao.articuloLevantamientoFisicoEAO.ArticuloLevantamientoFisicoEAOPersistence;
import contac.modelo.eao.articuloSalidaEAO.ArticuloSalidaEAO;
import contac.modelo.eao.articuloSalidaEAO.ArticuloSalidaEAOPersistence;
import contac.modelo.eao.articuloTrasladoEAO.ArticuloTrasladoEAO;
import contac.modelo.eao.articuloTrasladoEAO.ArticuloTrasladoEAOPersistence;
import contac.modelo.eao.estadoMovimientoEAO.EstadoMovimientoEAO;
import contac.modelo.eao.estadoMovimientoEAO.EstadoMovimientoEAOPersistence;
import contac.modelo.eao.genericEAO.GenericPersistenceEAOException;
import contac.modelo.eao.genericEAO.PersistenceClassNotFoundException;
import contac.modelo.eao.monedaEAO.MonedaEAO;
import contac.modelo.eao.monedaEAO.MonedaEAOPersistence;
import contac.modelo.eao.movimientoInventarioEAO.MovimientoInventarioEAO;
import contac.modelo.eao.movimientoInventarioEAO.MovimientoInventarioEAOPersistence;
import contac.modelo.eao.ordenEntradaEAO.OrdenEntradaEAO;
import contac.modelo.eao.ordenEntradaEAO.OrdenEntradaEAOPersistence;
import contac.modelo.eao.ordenLevantamientoFisicoEAO.OrdenLevantamientoFisicoEAO;
import contac.modelo.eao.ordenLevantamientoFisicoEAO.OrdenLevantamientoFisicoEAOPersistence;
import contac.modelo.eao.ordenSalidaEAO.OrdenSalidaEAO;
import contac.modelo.eao.ordenSalidaEAO.OrdenSalidaEAOPersistence;
import contac.modelo.eao.ordenTrasladoEAO.OrdenTrasladoEAO;
import contac.modelo.eao.ordenTrasladoEAO.OrdenTrasladoEAOPersistence;
import contac.modelo.entity.*;
import contac.servicio.seguridad.*;
import org.apache.log4j.Logger;
import org.hibernate.Hibernate;

import java.math.BigDecimal;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.*;

/**
 * Manager de Implementacion de Inventario Service
 * User: EMontenegro
 * Date: 11-02-11
 * Time: 09:41 PM
 */
public class ManagerInventarioServiceBusinessImpl extends UnicastRemoteObject implements ManagerInventarioServiceBusiness {

    //Apache log4j
    private static final Logger logger = Logger.getLogger(ManagerInventarioServiceBusinessImpl.class);

    //Acceso Capa EAO
    private OrdenEntradaEAO ordenEntradaEAO;
    private OrdenTrasladoEAO ordenTrasladoEAO;
    private OrdenSalidaEAO ordenSalidaEAO;
    private OrdenLevantamientoFisicoEAO ordenLevantamientoFisicoEAO;
    private AlmacenEAO almacenEAO;
    private EstadoMovimientoEAO estadoMovimientoEAO;
    private MonedaEAO monedaEAO;
    private ArticuloEntradaEAO articuloEntradaEAO;
    private ArticuloTrasladoEAO articuloTrasladoEAO;
    private ArticuloSalidaEAO articuloSalidaEAO;
    private ArticuloLevantamientoFisicoEAO articuloLevantamientoFisicoEAO;
    private MovimientoInventarioEAO movimientoInventarioEAO;

    //Acceso Manager de Autorizacion
    protected ManagerAutorizacionServiceBusiness mgrAutorizacion;
    protected ManagerSeguridadServiceBusiness mgrSeguridad;

    /**
     * Default Constructor
     *
     * @throws RemoteException, Exception
     */
    public ManagerInventarioServiceBusinessImpl() throws RemoteException {

        logger.debug("Creando servicio de Inventario Service...");

        //Inicializando accesos EAO
        ordenEntradaEAO = new OrdenEntradaEAOPersistence();
        ordenTrasladoEAO = new OrdenTrasladoEAOPersistence();
        ordenSalidaEAO = new OrdenSalidaEAOPersistence();
        ordenLevantamientoFisicoEAO = new OrdenLevantamientoFisicoEAOPersistence();
        almacenEAO = new AlmacenEAOPersistence();
        estadoMovimientoEAO = new EstadoMovimientoEAOPersistence();
        monedaEAO = new MonedaEAOPersistence();
        articuloEntradaEAO = new ArticuloEntradaEAOPersistence();
        articuloTrasladoEAO = new ArticuloTrasladoEAOPersistence();
        articuloSalidaEAO = new ArticuloSalidaEAOPersistence();
        articuloLevantamientoFisicoEAO = new ArticuloLevantamientoFisicoEAOPersistence();
        movimientoInventarioEAO = new MovimientoInventarioEAOPersistence();
    }

    /**
     * Constructor de Manager Catalogo con un usuario de autorizacion
     *
     * @param mgrAutorizacion, ManagerAutorizacionServiceBusiness
     * @throws RemoteException, Exception
     */
    public ManagerInventarioServiceBusinessImpl(ManagerAutorizacionServiceBusiness mgrAutorizacion) throws RemoteException {

        //Llamar al constructor padre
        this();

        //Inicializar servicio de autorizacion
        this.mgrAutorizacion = mgrAutorizacion;
        mgrSeguridad = new ManagerSeguridadServiceBusinessImpl(this.mgrAutorizacion);
    }

    //Iniciar servicio de transaccion
    private boolean initBusinessService(String rolname) throws ManagerInventarioServiceBusinessException {

        try {

            //Iniciar servicio de autorizacion
            if (mgrAutorizacion == null)
                logger.error("Servicio de autenticacion inactivo");

            //Check authentication
            mgrAutorizacion.isUserInRole(rolname);

            //Iniciar servicio transaccional
            return PersistenceManagementServiceFactory.beginTransaction();

        } catch (ManagerAutorizacionServiceBusinessException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (PersistenceManagementServiceFactoryException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (RemoteException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }

    //Detener servicio de transaccion
    private void stopBusinessService(boolean value) throws ManagerInventarioServiceBusinessException {

        try {

            //Commit all changes
            PersistenceManagementServiceFactory.commit(value);

            //Detener servicio transaccional
            PersistenceManagementServiceFactory.closeEntityManager(value);

        } catch (PersistenceManagementServiceFactoryException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }

    //Rollback servicio de transaccion
    private void rollbackBusinessService() throws ManagerInventarioServiceBusinessException {

        try {

            //Rollback all changes
            PersistenceManagementServiceFactory.rollback();

        } catch (PersistenceManagementServiceFactoryException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }

    @Override
    public List<Almacen> buscarAlmacenesPorUsuario() throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar almacenes autorizados para el usuario");

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLCATALOGOCONSULTA.toString());

        try {

            //Obtener compania del usuario
            Compania compania = mgrSeguridad.buscarUsuarioPorLogin(mgrAutorizacion.getUsername()).getCompania();

            //Obtener listado de almacenes por compania
            return almacenEAO.findAlmacenesPorCompania(compania.getId());

        } catch (ManagerAutorizacionServiceBusinessException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (ManagerSeguridadServiceBusinessException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (RemoteException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenEntrada buscarOrdenEntradaPorId(Integer idOrdenEntrada) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar orden de entrada con parametros: [idOrdenEntrada]: " + idOrdenEntrada);

        try {

            return ordenEntradaEAO.findById(idOrdenEntrada);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }

    @Override
    public List<OrdenEntrada> buscarOrdenesEntradaPorTipo(int tipoEntrada) throws ManagerInventarioServiceBusinessException,
            RemoteException {

        logger.info("Buscando ordenes de entrada con parametros: [tipoEntrada]: " + tipoEntrada);

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            boolean valueTipoEntrada = false;

            //Evaluar que el tipo de orden de entrada sea valido
            for (TiposEntrada tipo : TiposEntrada.values()) {
                if (tipo.getValue() == tipoEntrada)
                    valueTipoEntrada = true;
            }

            if (!valueTipoEntrada)
                throw new ManagerInventarioServiceBusinessException("Tipo de entrada no v\u00e1lido.  Favor verifique.");

            return ordenEntradaEAO.findByTipoEntrada(tipoEntrada);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public List<OrdenEntrada> buscarOrdenesEntradaPorEstados(List<String> estados) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.info("Buscar ordenes de entrada por estados");

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto
            List<Integer> idEstados = new ArrayList<Integer>();

            for (String estado : estados) {
                idEstados.add(estadoMovimientoEAO.findByAlias(estado).getId());
            }

            return ordenEntradaEAO.findByEstados(idEstados);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public List<OrdenEntrada> buscarOrdenesEntradaPorRangoFechas(Date fechaInicio, Date fechaFin) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar ordenes de entrada por rangos de fecha con parametros: [fechaInicio]: " + fechaInicio + ", " +
                " [fechaFin]: " + fechaFin);

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Validar datos
            if (fechaInicio == null)
                throw new ManagerInventarioServiceBusinessException("Debes ingresar una fecha de inicio.");

            if (fechaFin == null)
                throw new ManagerInventarioServiceBusinessException("Debes ingresar una fecha fin.");

            //Buscar ordenes de entrada por rangos de fechas
            return ordenEntradaEAO.findByFechas(fechaInicio, fechaFin);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenSalida buscarOrdenSalidaPorId(Integer idOrdenSalida) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar ordenes de salida con parametros: [idOrdenSalida]: " + idOrdenSalida);

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            return ordenSalidaEAO.findById(idOrdenSalida);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }

    @Override
    public List<OrdenSalida> buscarOrdenesSalidaPorEstados(List<String> estados) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar ordenes de salida por estados");

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto
            List<Integer> idEstados = new ArrayList<Integer>();

            for (String estado : estados) {
                idEstados.add(estadoMovimientoEAO.findByAlias(estado).getId());
            }

            return ordenSalidaEAO.findByEstados(idEstados);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public List<OrdenSalida> buscarOrdnesSalidaPorRangosFechas(Date fechaInicio, Date fechaFin) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar ordenes de salida por rangos de fecha con parametros: [fechaInicio]: " + fechaInicio + ", " +
                " [fechaFin]: " + fechaFin);

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Validar datos
            if (fechaInicio == null)
                throw new ManagerInventarioServiceBusinessException("Debes ingresar una fecha de inicio.");

            if (fechaFin == null)
                throw new ManagerInventarioServiceBusinessException("Debes ingresar una fecha fin.");

            //Buscar ordenes de salida por rangos de fechas
            return ordenSalidaEAO.findByFechas(fechaInicio, fechaFin);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenTraslado buscarOrdenTrasladoPorId(Integer idOrdenTraslado) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar ordenes de traslado con parametros: [idOrdenTraslado]: " + idOrdenTraslado);

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            return ordenTrasladoEAO.findById(idOrdenTraslado);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }

    @Override
    public List<OrdenTraslado> buscarOrdenesTrasladoPorEstados(List<String> estados) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar ordenes de traslado por estados");

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto
            List<Integer> idEstados = new ArrayList<Integer>();

            for (String estado : estados) {
                idEstados.add(estadoMovimientoEAO.findByAlias(estado).getId());
            }

            return ordenTrasladoEAO.findByEstados(idEstados);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public List<OrdenTraslado> buscarOrdenesTrasladoPorRangosFechas(Date fechaInicio, Date fechaFin) throws ManagerInventarioServiceBusinessException,
            RemoteException {

        logger.debug("Buscar ordenes de traslado por rangos de fecha con parametros: [fechaInicio]: " + fechaInicio + ", " +
                " [fechaFin]: " + fechaFin);

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Validar datos
            if (fechaInicio == null)
                throw new ManagerInventarioServiceBusinessException("Debes ingresar una fecha de inicio.");

            if (fechaFin == null)
                throw new ManagerInventarioServiceBusinessException("Debes ingresar una fecha fin.");

            //Buscar ordenes de traslado por rangos de fechas
            return ordenTrasladoEAO.findByFechas(fechaInicio, fechaFin);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenEntrada crearOrdenEntrada(int tipoEntrada, Date fechaAlta, Date fechaSolicitud, Integer idAlmacenIngreso,
                                          String personaEntrega, String descripcion, List<ArticuloEntrada> articulos)
            throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Creando orden de entrada con parametros: [tipoEntrada]:" + tipoEntrada + ", [fechaAlta]:" + fechaAlta +
                ", [almacenIngreso]:" + idAlmacenIngreso + ", [personaEntrega]: " + personaEntrega + ", [descripcion]:" +
                descripcion);

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto de ejecucion
            Almacen almacenIngreso = almacenEAO.findById(idAlmacenIngreso);
            Moneda moneda = almacenIngreso.getCompania().getMonedaReferencia();

            //Orden de entrada
            OrdenEntrada ordenEntrada = new OrdenEntrada();

            //Validar consistencia de datos.
            if (fechaAlta.after(new Date()))
                throw new ManagerInventarioServiceBusinessException("FECHA ALTA no puede ser posterior al dia de hoy.");

            if (articulos.isEmpty())
                throw new ManagerInventarioServiceBusinessException("Debes ingresar al menos un articulo.");

            //Evaluar tipo de orden de entrada
            if (TiposEntrada.ENTRADA_ORDINARIA.getValue() == tipoEntrada) {
                ordenEntrada = crearOrdenEntradaOrdinaria(fechaAlta, almacenIngreso, moneda, personaEntrega, descripcion, articulos);
            } else if (TiposEntrada.FACTURA_COMERCIAL.getValue() == tipoEntrada) {
                ordenEntrada = crearOrdenEntradaFacturaComercial(fechaAlta, almacenIngreso, personaEntrega, descripcion, articulos);
            } else if (TiposEntrada.POLIZA_IMPORTACION.getValue() == tipoEntrada) {
            }

            return ordenEntrada;

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenEntrada modificarOrdenEntrada(Integer idOrdenEntrada, int tipoEntrada, Date fechaAlta, Date fechaSolicitud,
                                              String personaEntrega, String descripcion, List<ArticuloEntrada> articulos)
            throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.info("Modificar orden de entrada con parametros: [idOrdenEntrada]: " + idOrdenEntrada + ", [tipo entrada]: " +
                tipoEntrada + ", [fecha alta]: " + fechaAlta + ", [fecha solicitud]: " + fechaSolicitud + ", [persona entrega]: " +
                personaEntrega + ", [descripcion]: " + descripcion);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto de ejecucion
            OrdenEntrada ordenEntrada = ordenEntradaEAO.findById(idOrdenEntrada);

            //Validar consistencia de datos
            if (!ordenEntrada.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado()))
                throw new ManagerInventarioServiceBusinessException("ESTADO no consistente para realizar una modificaci\u00f3n.");

            if (fechaAlta.after(new Date()))
                throw new ManagerInventarioServiceBusinessException("FECHA ALTA no puede ser posterior al dia de hoy.");

            if (articulos.isEmpty())
                throw new ManagerInventarioServiceBusinessException("Debes ingresar al menos un articulo.");

            //Actualizar datos generales de la orden de entrada
            ordenEntrada.setFechaAlta(fechaAlta);
            ordenEntrada.setFechaSolicitud(fechaSolicitud);
            ordenEntrada.setPersonaEntrega(personaEntrega);
            ordenEntrada.setDescripcion(descripcion);

            //Evaluar tipo de orden de entrada
            if (TiposEntrada.ENTRADA_ORDINARIA.getValue() == tipoEntrada) {
                ordenEntrada = modificarOrdenEntradaOrdinaria(ordenEntrada, articulos);
            } else if (TiposEntrada.FACTURA_COMERCIAL.getValue() == tipoEntrada) {
                //TODO: Implementar tipo de entrada factura comercial
            } else if (TiposEntrada.POLIZA_IMPORTACION.getValue() == tipoEntrada) {
                //TODO: Implementar tipo de entrada poliza de importacion
            }

            return ordenEntrada;

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenEntrada anularOrdenEntrada(Integer idOrdenEntrada) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Anulando orden de entrada con parametros: [id]: " + idOrdenEntrada);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto de ejecucion
            OrdenEntrada ordenEntrada = ordenEntradaEAO.findById(idOrdenEntrada);
            EstadoMovimiento estadoMovimiento = estadoMovimientoEAO.findByAlias(EstadosMovimiento.ANULADO.getEstado());

            //Evaluar si se encuentra en estado INGRESADO - APLICADO
            if (!ordenEntrada.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado()) ||
                    !ordenEntrada.getEstado().getAlias().equals(EstadosMovimiento.APLICADO.getEstado())) {
                throw new ManagerInventarioServiceBusinessException("Orden de Entrada se encuentra en un estado no válido. No se puede anular.");
            }

            //Obtener movimientos de inventario y eliminarlos
            for (ArticuloEntrada articulo : ordenEntrada.getArticulos()) {

                MovimientoInventario movimiento = articulo.getMovimientoInventario();

                if (movimiento != null) {
                    movimientoInventarioEAO.remove(movimiento.getId());
                    articulo.setMovimientoInventario(null);
                }
            }

            //Actulizar estado de la orden de entrada de inventario
            ordenEntrada.setEstado(estadoMovimiento);

            //Persistir orden de entrada
            return ordenEntradaEAO.update(ordenEntrada);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public void eliminarOrdenEntrada(Integer idOrdenEntrada) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Eliminando orden de entrada con parametros: [id]: " + idOrdenEntrada);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto de ejecucion
            OrdenEntrada ordenEntrada = ordenEntradaEAO.findById(idOrdenEntrada);

            //Evaluar si se encuentra en estado ingresado
            if (!ordenEntrada.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado())) {
                throw new ManagerInventarioServiceBusinessException("Orden de Entrada se encuentra en un estado no válido. No se puede eliminar.");
            }

            ordenEntradaEAO.remove(idOrdenEntrada);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenEntrada aplicarAjusteLevantamientoInventario(Integer idOrdenEntrada) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Aplicar ajuste levantamiento inventario con parametros: [id]: " + idOrdenEntrada);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto de ejecucion
            OrdenEntrada ordenEntrada = ordenEntradaEAO.findById(idOrdenEntrada);
            EstadoMovimiento estadoMovimiento = estadoMovimientoEAO.findByAlias(EstadosMovimiento.INGRESADO.getEstado());
            EstadoMovimiento estadoAplicado = estadoMovimientoEAO.findByAlias(EstadosMovimiento.APLICADO.getEstado());

            //Evaluar si se encuentra en estado ingresado
            if (!ordenEntrada.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado())) {
                throw new ManagerInventarioServiceBusinessException("Orden de Entrada se encuentra en un estado no válido. No se puede aplicar ajuste.");
            }

            //Evaluar ajuste de existencias por articulo ingresado
            for (ArticuloEntrada articulo : ordenEntrada.getArticulos()) {

                //***************************************************
                //Inicializar busqueda de existencias del producto
                //***************************************************
                Hibernate.initialize(articulo.getProducto().getExistencias());

                //***********************************************************************
                //1. Obtener existencias para el almacen procesado en la orden de entrada
                //***********************************************************************
                long cantExistenciaIni = 0;

                for (ProductoExistencia productoExistencia : articulo.getProducto().getExistencias()) {

                    if (productoExistencia.getId().getAlmacen().getId().longValue() == ordenEntrada.getAlmacen().getId().longValue())
                        cantExistenciaIni = productoExistencia.getCantidad();
                }

                //**************************************************************************
                //2. Obtener movimientos registrados hasta la fecha de alta orden de ingreso
                //**************************************************************************
                List<MovimientoInventario> movimientos = movimientoInventarioEAO.findByEstadoMovimiento(estadoMovimiento.getId(),
                        ordenEntrada.getAlmacen().getId(), ordenEntrada.getFechaAlta());

                //**************************************************************************
                //3. Calcular cantidad en existencia actual
                //**************************************************************************
                for (MovimientoInventario movimiento : movimientos) {
                    cantExistenciaIni += (movimiento.getAfectacion() * movimiento.getCantidad());
                }

                //**************************************************************************
                //4. Evaluar existenica fisica y crear movimiento de ajuste
                //**************************************************************************
                long cantAjuste = cantExistenciaIni - articulo.getCantidad();

                if (cantAjuste != 0) {
                    //Creating Movimiento inventario
                    MovimientoInventario movimientoInventario = new MovimientoInventario();
                    movimientoInventario.setAlmacen(ordenEntrada.getAlmacen());
                    movimientoInventario.setArticuloEntrada(articulo);
                    movimientoInventario.setEstado(estadoMovimiento);
                    movimientoInventario.setFechaAlta(ordenEntrada.getFechaAlta());
                    movimientoInventario.setAfectacion(cantAjuste < 0 ? new Integer(-1).shortValue() : new Integer(1).shortValue());
                    movimientoInventario.setCantidad(cantAjuste < 0 ? cantAjuste * -1 : cantAjuste);

                    //Setting movimiento inventario al articulo
                    articulo.setMovimientoInventario(movimientoInventario);
                }
            }

            //Actualizar estado de la orden de entrada de recuento fisico APLICADO!
            ordenEntrada.setEstado(estadoAplicado);

            //Persistir orden de entrada
            return ordenEntradaEAO.update(ordenEntrada);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenTraslado crearOrdenTraslado(Date fechaAlta, Date fechaSolicitud, Integer idAlmacenSalida,
                                            Integer idAlmacenIngreso, String personaEntrega, String personaRecibe,
                                            String descripcion, List<ArticuloTraslado> articulos)
            throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Creando orden de traslado con parametros: [fechaAlta]: " + fechaAlta + ", [fechaSolicitud]: " + fechaSolicitud +
                ", [idAlmacenSalida]:" + idAlmacenSalida + ", [idAlmacenIngreso]: " + idAlmacenIngreso + ", [personaEntrega]: " +
                ", [personaRecibe]: " + personaRecibe + ", [descripcion]: " + descripcion);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto de ejecucion
            Almacen almacenSalida = almacenEAO.findById(idAlmacenSalida);
            Almacen almacenIngreso = almacenEAO.findById(idAlmacenIngreso);
            EstadoMovimiento estado = estadoMovimientoEAO.findByAlias(EstadosMovimiento.INGRESADO.getEstado());

            //Obtener numero consecutivo de traslado
            long noTraslado = ordenTrasladoEAO.obtenerNoTraslado();

            //Validar consistencia de datos
            if (fechaAlta.after(new Date()))
                throw new ManagerInventarioServiceBusinessException("FECHA ALTA no puede ser posterior al dia de hoy.");

            if (personaEntrega.equals(""))
                throw new ManagerInventarioServiceBusinessException("Debes registrar a una persona que entrega.");

            if (personaRecibe.equals(""))
                throw new ManagerInventarioServiceBusinessException("Debes registrar a una persona que recibe.");

            if (descripcion.equals(""))
                throw new ManagerInventarioServiceBusinessException("Debes registrar una descripción para este traslado.");

            if (articulos.isEmpty())
                throw new ManagerInventarioServiceBusinessException("Debes ingresar al menos un articulo.");

            //Crear orden de traslado en estado preliminar INGRESADO
            OrdenTraslado ordenTraslado = new OrdenTraslado();
            ordenTraslado.setNoMovimiento(noTraslado);
            ordenTraslado.setAlmacenSalida(almacenSalida);
            ordenTraslado.setAlmacenEntrada(almacenIngreso);
            ordenTraslado.setPersonaEntrega(personaEntrega);
            ordenTraslado.setPersonaRecibe(personaRecibe);
            ordenTraslado.setDescripcion(descripcion);
            ordenTraslado.setFechaAlta(fechaAlta);
            ordenTraslado.setEstado(estado);
            ordenTraslado.setMoneda(almacenIngreso.getCompania().getMonedaReferencia());
            ordenTraslado.setMontoTotal(new BigDecimal(0.00).setScale(4, BigDecimal.ROUND_HALF_EVEN));

            //Persistir orden de traslado
            ordenTrasladoEAO.create(ordenTraslado);

            //Crear movimientos de inventario
            double costoNeto = 0.0;
            long renglon = 1;

            for (ArticuloTraslado articulo : articulos) {

                //Borrar articulos con cantidad menor o igual a zero
                if (articulo.getCantidad() <= 0) {
                    articulos.remove(articulo);
                    continue;
                }

                //Calcular costo del traslado
                costoNeto += articulo.getCosto().doubleValue() * articulo.getCantidad();
                articulo.setOrdenTraslado(ordenTraslado);
                articulo.setRenglon(renglon);

                //Creating movimientos de inventario de salida y entrada

                //<Movimiento de Salida de inventario>
                MovimientoInventario movimientoSalida = new MovimientoInventario();
                movimientoSalida.setFechaAlta(fechaAlta);
                movimientoSalida.setAfectacion(new Integer(-1).shortValue());
                movimientoSalida.setCantidad(articulo.getCantidad());
                movimientoSalida.setAlmacen(almacenSalida);
                movimientoSalida.setArticuloTraslado(articulo);
                movimientoSalida.setEstado(estado);
                movimientoSalida.setProducto(articulo.getProducto());

                //<Movimiento de ingreso de inventario>
                MovimientoInventario movimientoIngreso = new MovimientoInventario();
                movimientoIngreso.setFechaAlta(fechaAlta);
                movimientoIngreso.setAfectacion(new Integer(1).shortValue());
                movimientoIngreso.setCantidad(articulo.getCantidad());
                movimientoIngreso.setAlmacen(almacenIngreso);
                movimientoIngreso.setArticuloTraslado(articulo);
                movimientoIngreso.setEstado(estado);
                movimientoIngreso.setProducto(articulo.getProducto());

                Set<MovimientoInventario> setMovimientos = new HashSet<MovimientoInventario>();
                setMovimientos.add(movimientoSalida);
                setMovimientos.add(movimientoIngreso);

                articulo.setMovimientosInventario(setMovimientos);

                //Actualizar renglon
                renglon += 1;
            }

            //Setting monto total inventario
            ordenTraslado.setMontoTotal(new BigDecimal(costoNeto).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenTraslado.setArticulos(new HashSet<ArticuloTraslado>(articulos));

            //Persist orden de traslado
            return ordenTrasladoEAO.update(ordenTraslado);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenTraslado modificarOrdenTraslado(Integer idOrdenTraslado, Date fechaAlta, Date fechaSolicitud,
                                                String personaEntrega, String personaRecibe, String descripcion,
                                                List<ArticuloTraslado> articulos) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Modificando orden de traslado con parametros: [idOrdenTraslado]: " + idOrdenTraslado + ", [fechaAlta]: " +
                fechaAlta + ", [fechaSolicitud]: " + fechaSolicitud + ", [personaEntrega]: " + personaEntrega + ", [personaRecibe]: " +
                personaRecibe + ", [descripcion]: " + descripcion);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar contexto de ejecucion
            OrdenTraslado ordenTraslado = ordenTrasladoEAO.findById(idOrdenTraslado);

            //Validar consistencia de datos
            if (fechaAlta.after(new Date()))
                throw new ManagerInventarioServiceBusinessException("FECHA ALTA no puede ser posterior al dia de hoy.");

            if (personaEntrega.equals(""))
                throw new ManagerInventarioServiceBusinessException("Debes registrar a una persona que entrega.");

            if (personaRecibe.equals(""))
                throw new ManagerInventarioServiceBusinessException("Debes registrar a una persona que recibe.");

            if (descripcion.equals(""))
                throw new ManagerInventarioServiceBusinessException("Debes registrar una descripción para este traslado.");

            if (articulos.isEmpty())
                throw new ManagerInventarioServiceBusinessException("Debes ingresar al menos un articulo.");

            //Eliminar articulos del traslado
            for (ArticuloTraslado articulo : ordenTraslado.getArticulos()) {
                articuloTrasladoEAO.remove(articulo.getId());
            }

            //Modificar orden de traslado
            ordenTraslado.setFechaAlta(fechaAlta);
            ordenTraslado.setPersonaEntrega(personaEntrega);
            ordenTraslado.setPersonaRecibe(personaRecibe);
            ordenTraslado.setDescripcion(descripcion);
            ordenTraslado.setMontoTotal(new BigDecimal(0).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenTraslado.setArticulos(null);

            //Persistir orden de traslado
            ordenTraslado = ordenTrasladoEAO.update(ordenTraslado);

            //Crear movimientos de inventario
            double costoNeto = 0.0;
            long renglon = 1;

            for (ArticuloTraslado articulo : articulos) {

                //Borrar articulos con cantidad menor o igual a zero
                if (articulo.getCantidad() <= 0) {
                    articulos.remove(articulo);
                    continue;
                }

                //Calcular costo del traslado
                costoNeto += articulo.getCosto().doubleValue() * articulo.getCantidad();
                articulo.setOrdenTraslado(ordenTraslado);
                articulo.setRenglon(renglon);

                //Creating movimientos de inventario de salida y entrada

                //<Movimiento de Salida de inventario>
                MovimientoInventario movimientoSalida = new MovimientoInventario();
                movimientoSalida.setFechaAlta(fechaAlta);
                movimientoSalida.setAfectacion(new Integer(-1).shortValue());
                movimientoSalida.setCantidad(articulo.getCantidad());
                movimientoSalida.setAlmacen(ordenTraslado.getAlmacenSalida());
                movimientoSalida.setArticuloTraslado(articulo);
                movimientoSalida.setEstado(ordenTraslado.getEstado());
                movimientoSalida.setProducto(articulo.getProducto());

                //<Movimiento de ingreso de inventario>
                MovimientoInventario movimientoIngreso = new MovimientoInventario();
                movimientoIngreso.setFechaAlta(fechaAlta);
                movimientoIngreso.setAfectacion(new Integer(1).shortValue());
                movimientoIngreso.setCantidad(articulo.getCantidad());
                movimientoIngreso.setAlmacen(ordenTraslado.getAlmacenEntrada());
                movimientoIngreso.setArticuloTraslado(articulo);
                movimientoIngreso.setEstado(ordenTraslado.getEstado());
                movimientoIngreso.setProducto(articulo.getProducto());

                Set<MovimientoInventario> setMovimientos = new HashSet<MovimientoInventario>();
                setMovimientos.add(movimientoSalida);
                setMovimientos.add(movimientoIngreso);

                articulo.setMovimientosInventario(setMovimientos);

                //Actualizar renglon
                renglon += 1;
            }

            //Setting monto total inventario
            ordenTraslado.setMontoTotal(new BigDecimal(costoNeto).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenTraslado.setArticulos(new HashSet<ArticuloTraslado>(articulos));

            //actualizar articulos de orden de traslado
            return ordenTrasladoEAO.update(ordenTraslado);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public void anularOrdenTraslado(Integer idOrdenTraslado) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Anular orden de traslado con parametros: [idOrdenTraslado]: " + idOrdenTraslado);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar contexto de ejecucion
            OrdenTraslado ordenTraslado = ordenTrasladoEAO.findById(idOrdenTraslado);
            EstadoMovimiento estadoAnulado = estadoMovimientoEAO.findByAlias(EstadosMovimiento.ANULADO.getEstado());

            //Validar estado INGRESADO
            if (!ordenTraslado.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado()))
                throw new ManagerInventarioServiceBusinessException("Orden de Traslado se encuentra en un estado no válido. " +
                        "No se puede anular.");

            //Eliminar movimientos de inventario de los articulos
            for (ArticuloTraslado articulo : ordenTraslado.getArticulos()) {
                for (MovimientoInventario movimiento : articulo.getMovimientosInventario()) {
                    movimientoInventarioEAO.remove(movimiento.getId());
                }

                //Setting movimientos de inventario
                articulo.setMovimientosInventario(null);
            }

            //Actualizar orden de traslado
            ordenTraslado.setEstado(estadoAnulado);

            ordenTrasladoEAO.update(ordenTraslado);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenSalida crearOrdenSalida(Date fechaAlta, Date fechaSolicitud, Integer idAlmacenSalida, String personaAutoriza,
                                        String descripcion, List<ArticuloSalida> articulos) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Crear orden de salida con parametros: [fechaAlta]: " + fechaAlta + ", [fechaSolicitud]: " + fechaSolicitud +
                ", [idAlmacenSalida]: " + idAlmacenSalida + ", [personaAutoriza]: " + personaAutoriza + ", [descripcion]: " +
                descripcion);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto
            Almacen almacenSalida = almacenEAO.findById(idAlmacenSalida);
            EstadoMovimiento estado = estadoMovimientoEAO.findByAlias(EstadosMovimiento.INGRESADO.getEstado());

            //Obtener numero consecutivo de salida
            long noSalida = ordenSalidaEAO.obtenerNoSalida();

            //Validar consistencia de datos
            if (fechaAlta.after(new Date()))
                throw new ManagerInventarioServiceBusinessException("FECHA ALTA no puede ser posterior al dia de hoy.");

            if (personaAutoriza.equals(""))
                throw new ManagerInventarioServiceBusinessException("PERSONA AUTORIZA es un dato requerido.");

            if (descripcion.equals(""))
                throw new ManagerInventarioServiceBusinessException("DESCRIPCION es un dato requerido.");

            if (articulos == null || articulos.isEmpty())
                throw new ManagerInventarioServiceBusinessException("ARTICULOS DE SALIDA deben contener al menos un registro.");

            //Crear encabezado de orden de salida y persistirlo
            OrdenSalida ordenSalida = new OrdenSalida();
            ordenSalida.setNoMovimiento(noSalida);
            ordenSalida.setFechaAlta(fechaAlta);
            ordenSalida.setDescripcion(descripcion);
            ordenSalida.setPersonaAutoriza(personaAutoriza);
            ordenSalida.setAlmacen(almacenSalida);
            ordenSalida.setEstado(estado);
            ordenSalida.setMoneda(almacenSalida.getCompania().getMonedaReferencia());
            ordenSalida.setMontoTotal(new BigDecimal(0.00).setScale(4, BigDecimal.ROUND_HALF_EVEN));

            //Crear detalles de orden de salida
            double costoNeto = 0.0;
            long renglon = 1;

            for (ArticuloSalida articulo : articulos) {

                //Borrar articulos con cantidad menor o igual a zero
                if (articulo.getCantidad() <= 0) {
                    articulos.remove(articulo);
                    continue;
                }

                //Calcular costo de la salida
                costoNeto += articulo.getCosto().doubleValue() * articulo.getCantidad();
                articulo.setOrdenSalida(ordenSalida);
                articulo.setRenglon(renglon);

                //Creating movimientos de inventario de salida
                MovimientoInventario movimiento = new MovimientoInventario();
                movimiento.setAlmacen(almacenSalida);
                movimiento.setAfectacion(new Integer(-1).shortValue());
                movimiento.setCantidad(articulo.getCantidad());
                movimiento.setFechaAlta(fechaAlta);
                movimiento.setArticuloSalida(articulo);
                movimiento.setEstado(estado);
                movimiento.setProducto(articulo.getProducto());

                //Setting movimiento al articulo
                articulo.setMovimientoInventario(movimiento);

                //Actualizar renglon
                renglon += 1;
            }

            //Setting monto total de inventario
            ordenSalida.setMontoTotal(new BigDecimal(costoNeto).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenSalida.setArticulos(new HashSet<ArticuloSalida>(articulos));

            //Actualizar orden de traslado
            return ordenSalidaEAO.create(ordenSalida);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenSalida modificarOrdenSalida(Integer idOrdenSalida, Date fechaAlta, Date fechaSolicitud, String personaAutoriza,
                                            String descripcion, List<ArticuloSalida> articulos) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Modificar orden de salida con parametros: [idOrdenSalida]: " + idOrdenSalida + ", [fechaAlta]: " + fechaAlta +
                ", [fechaSolicitud]: " + fechaSolicitud + ", [personaAutoriza]: " + personaAutoriza + ", [descripcion]: " +
                descripcion);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto
            OrdenSalida ordenSalida = ordenSalidaEAO.findById(idOrdenSalida);

            //Validar consistencia de datos
            if (!ordenSalida.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado()))
                throw new ManagerInventarioServiceBusinessException("Orden de Salida se encuentra en un estado no válido. No se puede modificar.");

            if (fechaAlta.after(new Date()))
                throw new ManagerInventarioServiceBusinessException("FECHA ALTA no puede ser posterior al dia de hoy.");

            if (personaAutoriza.equals(""))
                throw new ManagerInventarioServiceBusinessException("PERSONA AUTORIZA es un dato requerido.");

            if (descripcion.equals(""))
                throw new ManagerInventarioServiceBusinessException("DESCRIPCION es un dato requerido.");

            if (articulos == null || articulos.isEmpty())
                throw new ManagerInventarioServiceBusinessException("ARTICULOS DE SALIDA deben contener al menos un registro.");

            //Eliminar registros de articulos de salida
            for (ArticuloSalida articulo : ordenSalida.getArticulos()) {
                articuloSalidaEAO.remove(articulo.getId());
            }

            //Calcular nuevo costo neto de salida de inventario
            double costoNeto = 0.0;
            long renglon = 1;

            for (ArticuloSalida articulo : articulos) {

                //Borrar articulos con cantidad menor o igual a zero
                if (articulo.getCantidad() <= 0) {
                    articulos.remove(articulo);
                    continue;
                }

                //Calcular costo de la salida
                costoNeto += articulo.getCosto().doubleValue() * articulo.getCantidad();
                articulo.setOrdenSalida(ordenSalida);
                articulo.setRenglon(renglon);

                //Creating movimientos de inventario de salida
                MovimientoInventario movimiento = new MovimientoInventario();
                movimiento.setAlmacen(ordenSalida.getAlmacen());
                movimiento.setAfectacion(new Integer(-1).shortValue());
                movimiento.setCantidad(articulo.getCantidad());
                movimiento.setFechaAlta(fechaAlta);
                movimiento.setArticuloSalida(articulo);
                movimiento.setEstado(ordenSalida.getEstado());
                movimiento.setProducto(articulo.getProducto());

                //Setting movimiento al articulo
                articulo.setMovimientoInventario(movimiento);

                //Actualizar renglon
                renglon += 1;
            }

            //Setting monto total de inventario
            ordenSalida.setMontoTotal(new BigDecimal(costoNeto).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenSalida.setArticulos(new HashSet<ArticuloSalida>(articulos));

            return ordenSalidaEAO.update(ordenSalida);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenSalida anularOrdenSalida(Integer idOrdenSalida) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Anulando orden de salida con parametros: [idOrdenSalida]: " + idOrdenSalida);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto
            OrdenSalida ordenSalida = ordenSalidaEAO.findById(idOrdenSalida);
            EstadoMovimiento estadoAnulado = estadoMovimientoEAO.findByAlias(EstadosMovimiento.ANULADO.getEstado());

            //Validar estado para anular
            if (!ordenSalida.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado()))
                throw new ManagerInventarioServiceBusinessException("Orden de Salida se encuentra en un estado no válido. No se puede anular");


            //Eliminar movimientos de inventario
            for (ArticuloSalida articulo : ordenSalida.getArticulos()) {
                movimientoInventarioEAO.remove(articulo.getMovimientoInventario().getId());
                articulo.setMovimientoInventario(null);
            }

            //Actualizar orden de salida
            ordenSalida.setEstado(estadoAnulado);

            return ordenSalidaEAO.update(ordenSalida);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenLevantamientoFisico crearOrdenLevantamientoFisico(Date fechaAlta, Date fechaSolicitud, Integer idAlmacenIngreso,
                                                                  String descripcion, List<ArticuloLevantamientoFisico> articulos)
            throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Creando orden de levantamiento fisico con parametros: [fechaAlta]: " + fechaAlta + ", [fechaSolicitud]:" +
                fechaSolicitud + ", [idAlmacenIngreso]: " + idAlmacenIngreso + ", [descripcion]: " + descripcion);


        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //1. PREPARAR EL CONTEXTO DE EJECUCION
            long noMovimiento = ordenLevantamientoFisicoEAO.obtenerNoLevantamiento();
            Almacen almacen = almacenEAO.findById(idAlmacenIngreso);
            EstadoMovimiento estado = estadoMovimientoEAO.findByAlias(EstadosMovimiento.INGRESADO.getEstado());

            //2. VALIDAR DATOS DE LA ORDEN
            if (fechaAlta.after(new Date()))
                throw new ManagerInventarioServiceBusinessException("FECHA ALTA no puede ser posterior a la fecha actual.");

            if (descripcion.equals(""))
                throw new ManagerInventarioServiceBusinessException("DESCRIPCION es un dato requerido.");

            if (articulos == null || articulos.size() <= 0)
                throw new ManagerInventarioServiceBusinessException("ARTICULOS en levantamiento físico deben contener al menos un registro.");


            //3. CREAR LEVANTAMIENTO INVENTARIO
            OrdenLevantamientoFisico ordenLevantamiento = new OrdenLevantamientoFisico();
            ordenLevantamiento.setNoMovimiento(noMovimiento);
            ordenLevantamiento.setDescripcion(descripcion);
            ordenLevantamiento.setTipoActualizacion(TipoActualizacionFisico.PARCIAL.getValue());
            ordenLevantamiento.setFechaAlta(fechaAlta);
            ordenLevantamiento.setAlmacen(almacen);
            ordenLevantamiento.setFechaSolicitud(fechaSolicitud);
            ordenLevantamiento.setMoneda(almacen.getCompania().getMonedaReferencia());
            ordenLevantamiento.setMontoTotal(new BigDecimal(0.00).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenLevantamiento.setEstado(estado);

            //4. CREAR DETALLE LEVANTAMIENTO FISICO
            double costoNeto = 0.0;
            long renglon = 1;

            for (ArticuloLevantamientoFisico articulo : articulos) {

                //Borrar articulos con cantidad menor o igual a zero
                if (articulo.getCantidad() <= 0) {
                    articulos.remove(articulo);
                    continue;
                }

                //Setting orden de levantamiento
                costoNeto += articulo.getCosto().doubleValue() * articulo.getCantidad();
                articulo.setOrdenLevantamientoFisico(ordenLevantamiento);
                articulo.setRenglon(renglon);

                //Actualizar renglon
                renglon += 1;
            }

            //5. ACTUALIZAR DETALLE Y DATOS DE ENCABEZADO
            ordenLevantamiento.setMontoTotal(new BigDecimal(costoNeto).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenLevantamiento.setArticulos(new HashSet<ArticuloLevantamientoFisico>(articulos));

            //Persistir encabezado de levantamiento fisico
            return ordenLevantamientoFisicoEAO.create(ordenLevantamiento);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenLevantamientoFisico modificarOrdenLevantamientoFisico(Integer idOrdenLevantamiento, Date fechaAlta,
                                                                      Date fechaSolicitud, String descripcion,
                                                                      List<ArticuloLevantamientoFisico> articulos)
            throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Modificar orden de lavantamiento fisico con parametros: [idOrdenLevantamiento]: " + idOrdenLevantamiento +
                ", [fechaAlta]: " + fechaAlta + ", [fechaSolicitud]: " + fechaSolicitud + ", [descripcion]: " + descripcion);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //1. PREPARAR EL CONTEXTO DE EJECUCION
            OrdenLevantamientoFisico ordenLevantamiento = ordenLevantamientoFisicoEAO.findById(idOrdenLevantamiento);

            //2. VALIDAR DATOS DE LA ORDEN
            if (!ordenLevantamiento.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado()))
                throw new ManagerInventarioServiceBusinessException("Orden Levantamiento Físico se encuentra en un estado no válido. " +
                        "no se puede proceder a la modificación.");

            if (fechaAlta.after(new Date()))
                throw new ManagerInventarioServiceBusinessException("FECHA ALTA no puede ser posterior a la fecha actual.");

            if (descripcion.equals(""))
                throw new ManagerInventarioServiceBusinessException("DESCRIPCION es un dato requerido.");

            if (articulos == null || articulos.size() <= 0)
                throw new ManagerInventarioServiceBusinessException("ARTICULOS en levantamiento físico deben contener al menos un registro.");

            //3. MODIFICAR DETALLE LEVANTAMIENTO FISICO
            double costoNeto = 0.0;
            long renglon = 1;

            for (ArticuloLevantamientoFisico articulo : articulos) {

                if (articulo.isCreate()) {

                    //Borrar articulos con cantidad menor o igual a zero
                    if (articulo.getCantidad() <= 0) {
                        articulos.remove(articulo);
                        continue;
                    }
                }

                if (articulo.isUpdate()) {

                    //Borrar articulos con cantidad menor o igual a zero
                    if (articulo.getCantidad() <= 0) {
                        articuloLevantamientoFisicoEAO.remove(articulo.getId());
                        articulos.remove(articulo);
                        continue;
                    }
                }

                //Setting orden de entrada
                costoNeto += articulo.getCosto().doubleValue() * articulo.getCantidad();
                articulo.setOrdenLevantamientoFisico(ordenLevantamiento);
                articulo.setRenglon(renglon);

                //Actualizar renglon
                renglon += 1;
            }

            //4. ACTUALIZAR DATOS LEVANTAMIENTO FISICO Y PERSISTIR
            ordenLevantamiento.setFechaAlta(fechaAlta);
            ordenLevantamiento.setFechaSolicitud(fechaSolicitud);
            ordenLevantamiento.setDescripcion(descripcion);
            ordenLevantamiento.setMontoTotal(new BigDecimal(costoNeto).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenLevantamiento.setArticulos(new HashSet<ArticuloLevantamientoFisico>(articulos));

            return ordenLevantamientoFisicoEAO.update(ordenLevantamiento);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public OrdenLevantamientoFisico aplicarOrdenLevantamientoFisico(Integer idOrdenLevantamiento) throws ManagerInventarioServiceBusinessException,
            RemoteException {
        return null;  //To change body of implemented methods use File | Settings | File Templates.
    }

    @Override
    public void eliminarOrdenLevantamientoFisico(Integer idOrdenLevantamientoFisico) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Eliminar orden de levantamiento fisico con parametros: [idOrdenLevantamiento]: " + idOrdenLevantamientoFisico);

        //Iniciar servicio de autenticacion
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //1. PREPARAR CONTEXTO DE EJECUCION
            OrdenLevantamientoFisico ordenLevantamientoFisico = ordenLevantamientoFisicoEAO.findById(idOrdenLevantamientoFisico);

            //2. VALIDAR DATOS DE LA ORDEN
            if (!ordenLevantamientoFisico.getEstado().getAlias().equals(EstadosMovimiento.INGRESADO.getEstado()))
                throw new ManagerInventarioServiceBusinessException("Orden Levantamiento Físico se encuentra en un estado no válido. " +
                        "no se puede proceder a la eliminación.");

            //3. BORRAR ORDEN DE LEVANTAMIENTO FISICO
            ordenLevantamientoFisicoEAO.remove(idOrdenLevantamientoFisico);

        } catch (PersistenceClassNotFoundException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }
    }

    @Override
    public List<OrdenLevantamientoFisico> buscarOrdenesLevantamientoFisicoPorEstados(List<String> estados) throws ManagerInventarioServiceBusinessException, RemoteException {

        logger.debug("Buscar ordenes de levantamiento fisico por estados");

        //Iniciar servicio authentication
        boolean value = initBusinessService(Roles.ROLINVENTARIOADMIN.toString());

        try {

            //Preparar el contexto
            List<Integer> idEstados = new ArrayList<Integer>();

            for (String estado : estados) {
                idEstados.add(estadoMovimientoEAO.findByAlias(estado).getId());
            }

            return ordenLevantamientoFisicoEAO.findByEstados(idEstados);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        } finally {
            stopBusinessService(value);
        }

    }

    @Override
    public void calcularMaximosMinimos() throws ManagerInventarioServiceBusinessException, RemoteException {
        //To change body of implemented methods use File | Settings | File Templates.
    }

    //**************************************************************************************
    //PRIVATE BUSINESS LOGIC
    //**************************************************************************************

    /**
     * Crear orden de entrada ordinaria producto de un ingreso directo
     *
     * @param fechaAlta,      Fecha de alta del movimiento de ingreso
     * @param almacen,        Almacen de ingreso
     * @param personaEntrega, Persona que realiza entrega
     * @param articulos,      Listado de articulos a ingresar
     * @return OrdenEntrada
     * @throws ManagerInventarioServiceBusinessException,
     *          Exception
     */
    private OrdenEntrada crearOrdenEntradaOrdinaria(Date fechaAlta, Almacen almacen, Moneda moneda, String personaEntrega, String descripcion,
                                                    List<ArticuloEntrada> articulos) throws ManagerInventarioServiceBusinessException {

        logger.debug("Creando orden de entrada ordinaria con parametros: [FechaAlta]:" + fechaAlta);

        try {

            //1. OBTENER NUMERO DE ORDEN CONSECUTIVO
            long noOrden = ordenEntradaEAO.obtenerNoEntrada();
            EstadoMovimiento estado = estadoMovimientoEAO.findByAlias(EstadosMovimiento.INGRESADO.getEstado());

            //2. PERSISTIR ORDEN DE ENTRADA
            OrdenEntrada ordenEntrada = new OrdenEntrada();
            ordenEntrada.setTipoEntrada(TiposEntrada.ENTRADA_ORDINARIA.getValue());
            ordenEntrada.setNoMovimiento(noOrden);
            ordenEntrada.setAlmacen(almacen);
            ordenEntrada.setFechaAlta(fechaAlta);
            ordenEntrada.setMoneda(moneda);
            ordenEntrada.setEstado(estado);
            ordenEntrada.setDescripcion(descripcion);
            ordenEntrada.setPersonaEntrega(personaEntrega);
            ordenEntrada.setMontoTotal(new BigDecimal(0.00).setScale(4, BigDecimal.ROUND_HALF_EVEN));

            //3. PERSISTIR ARTICULOS ENTRADA
            double CostoNeto = 0.0;
            long renglon = 1;

            for (ArticuloEntrada articulo : articulos) {

                //Borrar articulos con cantidad menor o igual a zero
                if (articulo.getCantidad() <= 0) {
                    articulos.remove(articulo);
                    continue;
                }

                //Setting orden de entrada
                CostoNeto += articulo.getCosto().doubleValue() * articulo.getCantidad();
                articulo.setOrdenEntrada(ordenEntrada);
                articulo.setRenglon(renglon);

                //Creating Movimiento inventario
                MovimientoInventario movimientoInventario = new MovimientoInventario();
                movimientoInventario.setFechaAlta(ordenEntrada.getFechaAlta());
                movimientoInventario.setAfectacion(new Integer(1).shortValue());
                movimientoInventario.setCantidad(articulo.getCantidad());
                movimientoInventario.setAlmacen(almacen);
                movimientoInventario.setArticuloEntrada(articulo);
                movimientoInventario.setEstado(estado);
                movimientoInventario.setProducto(articulo.getProducto());

                //Setting movimiento inventario
                articulo.setMovimientoInventario(movimientoInventario);

                //Actualizar renglon
                renglon += 1;
            }

            //<Persist articulos>
            ordenEntrada.setMontoTotal(new BigDecimal(CostoNeto).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenEntrada.setArticulos(new HashSet<ArticuloEntrada>(articulos));

            ordenEntrada = ordenEntradaEAO.create(ordenEntrada);

            return ordenEntrada;

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }

    /**
     * @param fechaAlta,      Fecha de alta orden de entrada
     * @param almacen,        Almacen de ingreso orden de entrada
     * @param personaEntrega,
     * @param articulos
     * @return
     * @throws ManagerInventarioServiceBusinessException
     *
     */
    private OrdenEntrada crearOrdenEntradaFacturaComercial(Date fechaAlta, Almacen almacen, String personaEntrega, String descripcion,
                                                           List<ArticuloEntrada> articulos) throws ManagerInventarioServiceBusinessException {
        throw new UnsupportedOperationException();
    }

    /**
     * @param fechaAlta
     * @param almacen
     * @param personaEntrega
     * @param articulos
     * @return
     * @throws ManagerInventarioServiceBusinessException
     *
     */
    private OrdenEntrada crearOrdenEntradaPolizaImportacion(Date fechaAlta, Almacen almacen, String personaEntrega,
                                                            List<ArticuloEntrada> articulos) throws ManagerInventarioServiceBusinessException {
        throw new UnsupportedOperationException();
    }

    /**
     * Modificar Orden Entrada Ordinaria
     *
     * @param ordenEntrada, Orden Entrada ordinaria
     * @param articulos,    Listado de articulos
     * @return OrdenEntrada
     * @throws ManagerInventarioServiceBusinessException,
     *          Exception
     */
    private OrdenEntrada modificarOrdenEntradaOrdinaria(OrdenEntrada ordenEntrada, List<ArticuloEntrada> articulos)
            throws ManagerInventarioServiceBusinessException {

        logger.debug("Modificando orden de entrada con parametros: [noMovimiento]: " + ordenEntrada.getNoMovimiento());

        try {

            //1. PREPARAR EL CONTEXTO
            EstadoMovimiento estado = estadoMovimientoEAO.findByAlias(EstadosMovimiento.INGRESADO.getEstado());

            //3. MODIFICAR DETALLE ORDEN DE ENTRADA
            double costoNeto = 0.0;
            long renglon = 1;

            for (Iterator it = articulos.iterator(); it.hasNext();) {

                ArticuloEntrada articulo = (ArticuloEntrada)it.next();

                if (articulo.isCreate()) {

                    //Borrar articulos con cantidad menor o igual a zero
                    if (articulo.getCantidad() <= 0) {
                        it.remove();
                        continue;
                    }

                    //Creando movimiento de inventario por articulo
                    MovimientoInventario movimientoInventario = new MovimientoInventario();
                    movimientoInventario.setAlmacen(ordenEntrada.getAlmacen());
                    movimientoInventario.setFechaAlta(ordenEntrada.getFechaAlta());
                    movimientoInventario.setAfectacion(new Integer(1).shortValue());
                    movimientoInventario.setCantidad(articulo.getCantidad());
                    movimientoInventario.setEstado(estado);
                    movimientoInventario.setArticuloEntrada(articulo);
                    movimientoInventario.setProducto(articulo.getProducto());

                    articulo.setMovimientoInventario(movimientoInventario);
                }

                if (articulo.isUpdate()) {

                    //Borrar articulos con cantidad menor o igual a zero
                    if (articulo.getCantidad() <= 0) {
                        articuloEntradaEAO.remove(articulo.getId());
                        it.remove();
                        continue;
                    }

                    //Actulizar cantidad movimiento inventario
                    articulo.getMovimientoInventario().setCantidad(articulo.getCantidad());
                }

                //Calculando el costo total por item
                costoNeto += articulo.getCosto().doubleValue() * articulo.getCantidad();


                //Setting orden de entrada en el articulo
                articulo.setOrdenEntrada(ordenEntrada);
                articulo.setRenglon(renglon);

                //Actualizar renglon
                renglon += 1;
            }

            //Setting nuevo costo neto de ingreso de inventario
            ordenEntrada.setMontoTotal(new BigDecimal(costoNeto).setScale(4, BigDecimal.ROUND_HALF_EVEN));
            ordenEntrada.setArticulos(new HashSet<ArticuloEntrada>(articulos));

            //4. PERSISTIR ORDE DE INGRESO DE INVENTARIO
            return ordenEntradaEAO.update(ordenEntrada);

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }

    /**
     * Calcular consumo promedio mensual del producto
     *
     * @param codigo, String
     * @return long
     * @throws ManagerInventarioServiceBusinessException,
     *          Exception
     */
    private long calcularConsumoPromedioMensualProducto(String codigo, Integer idAlmacen) throws ManagerInventarioServiceBusinessException {

        logger.debug("Calcular demanda producto con parametros: [codigo]: " + codigo + ", [idAlmacen]: " + idAlmacen);

        try {

            //1. PREPARAR EL CONTEXTO DE VARIABLES DE EJECUCION
            Date fechaHasta = new Date();

            Calendar calendario = Calendar.getInstance();
            calendario.setTime(fechaHasta);

            //Restar 6 meses a la fecha Hasta para obtener fecha Desde
            calendario.add(Calendar.MONTH, -6);

            //Demanda total del producto del periodo a evaluar
            long demandaTotal = 0;

            int dia = calendario.getActualMinimum(Calendar.DAY_OF_MONTH);
            int mes = calendario.get(Calendar.MONTH);
            int anio = calendario.get(Calendar.YEAR);
            calendario.set(anio, mes, dia);

            Date fechaDesde = calendario.getTime();

            //2. Obtener movimientos de inventario con afectacion negativa para el almacen de busqueda
            List<MovimientoInventario> movimientosInventario = movimientoInventarioEAO.findByProducto(codigo, idAlmacen,
                    fechaDesde, fechaHasta);

            //3. Sumar movimientos de inventario para calcular demanda total
            for (MovimientoInventario movimientoInventario : movimientosInventario) {
                demandaTotal += movimientoInventario.getCantidad();
            }

            //4. Calcular demanda promedio del producto
            long demandaProm = demandaTotal / 6;

            return demandaProm;

        } catch (GenericPersistenceEAOException e) {
            logger.error(e.getMessage(), e);
            throw new ManagerInventarioServiceBusinessException(e.getMessage(), e);
        }
    }
}
